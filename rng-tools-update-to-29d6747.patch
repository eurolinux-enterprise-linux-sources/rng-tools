diff -up ./configure.ac.update ./configure.ac
--- ./configure.ac.update	2017-11-09 07:34:35.753304392 -0500
+++ ./configure.ac	2017-11-09 07:35:56.699978450 -0500
@@ -34,11 +34,20 @@ AC_ARG_WITH([libgcrypt],
 
 dnl Make sure anyone changing configure.ac/Makefile.am has a clue
 AM_MAINTAINER_MODE
+AM_PROG_AS
 
 dnl Checks for programs
 AC_PROG_CC
 AC_PROG_RANLIB
 AC_PROG_GCC_TRADITIONAL
+AC_CANONICAL_HOST
+
+echo $host_cpu
+AM_CONDITIONAL([RDRAND], [test $host_cpu = x86_64])
+AS_IF([test $host_cpu = x86_64], [AC_DEFINE([HAVE_RDRAND],1,[Enable RDRAND])],[])
+
+AM_CONDITIONAL([DARN], [test $host_cpu = powerpc64le])
+AS_IF([test $host_cpu = powerpc64le], [AC_DEFINE([HAVE_DARN],1,[Enable DARN])],[])
 
 dnl Checks for header files.
 dnl AC_HEADER_STDC
diff -up ./Makefile.am.update ./Makefile.am
--- ./Makefile.am.update	2017-11-09 07:34:35.753304392 -0500
+++ ./Makefile.am	2017-11-09 07:35:56.699978450 -0500
@@ -10,8 +10,16 @@ man_MANS	 = rngd.8 rngtest.1
 noinst_LIBRARIES = librngd.a
 
 rngd_SOURCES	= rngd.h rngd.c	rngd_entsource.h rngd_entsource.c	\
-		  rngd_linux.h rngd_linux.c util.c 			\
-		  rngd_rdrand.c rdrand_asm.S
+		  rngd_linux.h rngd_linux.c util.c 
+
+if RDRAND
+rngd_SOURCES	+= rngd_rdrand.c rdrand_asm.S
+endif
+
+if DARN
+rngd_SOURCES	+= rngd_darn.c
+endif
+
 rngd_LDADD	= librngd.a
 rngd_LDFLAGS	= -lsysfs
 
diff -up ./rdrand_asm.S.update ./rdrand_asm.S
--- ./rdrand_asm.S.update	2017-11-09 07:34:35.745304425 -0500
+++ ./rdrand_asm.S	2017-11-09 07:35:56.700978446 -0500
@@ -18,8 +18,6 @@
  *
  */
 
-#if defined(__i386__) || defined(__x86_64__)
-
 #define ENTRY(x)	  \
 	.balign	64	; \
 	.globl	x	; \
@@ -349,8 +347,6 @@ aes_round_keys:
 	.space	11*16
 	.size	aes_round_keys, .-aes_round_keys
 
-#endif /* i386 or x86_64 */
-
 /*
  * This is necessary to keep the whole executable
  * from needing a writable stack.
diff -up ./rngd.8.in.update ./rngd.8.in
--- ./rngd.8.in.update	2017-11-09 07:34:35.751304400 -0500
+++ ./rngd.8.in	2017-11-09 07:35:56.700978446 -0500
@@ -9,16 +9,16 @@ rngd \- Check and feed random data from
 .B rngd
 [\fB\-b\fR, \fB\-\-background\fR]
 [\fB\-f\fR, \fB\-\-foreground\fR]
+[\fB\-d\fR, \fB\-\-debug\fR]
+[\fB\-l\fR, \fB\-\-list\fR]
+[\fB\-x\fR, \fB\-\-exclude\fR]
 [\fB\-i\fR, \fB\-\-ignorefail\fR]
 [\fB\-o\fR, \fB\-\-random-device=\fIfile\fR]
 [\fB\-p\fR, \fB\-\-pid-file=\fIfile\fR]
 [\fB\-r\fR, \fB\-\-rng-device=\fIfile\fR]
 [\fB\-s\fR, \fB\-\-random-step=\fInnn\fR]
 [\fB\-W\fR, \fB\-\-fill-watermark=\fInnn\fR]
-[\fB\-d\fR, \fB\-\-no-drng=\fI1|0\fR]
-[\fB\-n\fR, \fB\-\-no-tpm=\fI1|0\fR]
 [\fB\-q\fR, \fB\-\-quiet\fR]
-[\fB\-v\fR, \fB\-\-verbose\fR]
 [\fB\-?\fR, \fB\-\-help\fR]
 [\fB\-V\fR, \fB\-\-version\fR]
 .RI
@@ -49,6 +49,15 @@ Become a daemon (default)
 \fB\-f\fR, \fB\-\-foreground\fR
 Do not fork and become a daemon
 .TP
+\fB\-d\fR, \fB\-\-debug\fR
+Enable debug messages
+.TP
+\fB\-l\fR, \fB\-\-list\fR
+List the indexes and names of available entropy sources
+.TP
+\fB\-x\fR, \fB\-\-exclude\fR
+Disable entropy sources based on index reported from --list option
+.TP
 \fB\-p\fI file\fR, \fB\-\-pid-file=\fIfile\fR
 File used for recording daemon PID, and multiple exclusion
 (default: /var/run/rngd.pid)
@@ -79,18 +88,9 @@ entropy pool.  Low values will hurt syst
 starves.  Do not set \fIfill-watermark\fR above the size of the
 entropy pool (usually 4096 bits).
 .TP
-\fB\-d\fI 1|0\fR, \fB\-\-no-drng=\fI1|0\fR
-Do not use drng as a source of random number input (default:0)
-.TP
-\fB\-n\fI 1|0\fR, \fB\-\-no-tpm=\fI1|0\fR
-Do not use tpm as a source of random number input (default:0)
-.TP
 \fB\-q\fR, \fB\-\-quiet\fR
 Suppress error messages
 .TP
-\fB\-v\fR, \fB\-\-verbose\fR
-Report available entropy sources, and exit
-.TP
 \fB\-?\fR, \fB\-\-help\fR
 Give a short summary of all program options.
 .TP
@@ -105,3 +105,4 @@ Jeff Garzik \- jgarzik@pobox.com
 Matt Sottek
 .br
 Brad Hill
+
diff -up ./rngd.c.update ./rngd.c
--- ./rngd.c.update	2017-11-09 07:34:35.757304376 -0500
+++ ./rngd.c	2017-11-09 07:35:56.701978442 -0500
@@ -68,6 +68,7 @@ bool ignorefail = false; /* true if we i
 const char *argp_program_version =
 	"rngd " VERSION "\n"
 	"Copyright 2001-2004 Jeff Garzik\n"
+	"Copyright 2017 Neil Horman\n"
 	"Copyright (c) 2001 by Philipp Rumpf\n"
 	"This is free software; see the source for copying conditions.  There is NO "
 	"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.";
@@ -78,12 +79,18 @@ static char doc[] =
 	"Check and feed random data from hardware device to kernel entropy pool.\n";
 
 static struct argp_option options[] = {
+	{ "debug", 'd', 0, 0, "Enable debug output" },
+
 	{ "foreground",	'f', 0, 0, "Do not fork and become a daemon" },
 
 	{ "ignorefail", 'i', 0, 0, "Ignore repeated fips failures" },
 
 	{ "background", 'b', 0, 0, "Become a daemon (default)" },
 
+	{ "exclude", 'x', "n", 0, "Disable the numbered entropy source specified" },
+
+	{ "list", 'l', 0, 0, "List the operational entropy sources on this system and exit" },
+
 	{ "random-device", 'o', "file", 0,
 	  "Kernel device used for random number output (default: /dev/random)" },
 
@@ -101,13 +108,7 @@ static struct argp_option options[] = {
 
 	{ "quiet", 'q', 0, 0, "Suppress error messages" },
 
-	{ "verbose" ,'v', 0, 0, "Report available entropy sources" },
-
-	{ "no-drng", 'd', "1|0", 0,
-	  "Do not use drng as a source of random number input (default: 0)" },
-	
-	{ "no-tpm", 'n', "1|0", 0,
-	  "Do not use tpm as a source of random number input (default: 0)" },
+	{ "version" ,'v', 0, 0, "List rngd version" },
 
 	{ "entropy-count", 'e', "n", 0, "Number of entropy bits to support (default: 8), 1 <= n <= 8" },
 
@@ -119,49 +120,91 @@ static struct arguments default_argument
 	.pid_file	= "/var/run/rngd.pid",
 	.random_step	= 64,
 	.daemon		= true,
+	.list		= false,
 	.ignorefail	= false,
-	.enable_drng	= true,
-	.enable_tpm	= true,
 	.quiet		= false,
-	.verbose	= false,
 	.entropy_count	= 8,
 };
 struct arguments *arguments = &default_arguments;
 
-static struct rng rng_default = {
-	.rng_name	= "/dev/hwrng",
-	.rng_fd		= -1,
-	.xread		= xread,
+static enum {
+	ENT_HWRNG = 0,
+	ENT_TPM = 1,
+	ENT_RDRAND,
+	ENT_DARN,
+	ENT_MAX
+} entropy_indexes;
+
+static struct rng entropy_sources[ENT_MAX] = {
+	/* Note, the special char dev must be the first entry */
+	{
+		.rng_name	= "Hardware RNG Device",
+		.rng_fname      = "/dev/hwrng",
+		.rng_fd         = -1,
+		.xread          = xread,
+		.init           = init_entropy_source,
+	},
+	/* must be at index 1 */
+	{
+		.rng_name	= "TPM RNG Device",
+		.rng_fname      = "/dev/tpm0",
+		.rng_fd         = -1,
+		.xread          = xread_tpm,
+		.init           = init_tpm_entropy_source,
+	},
+	{
+		.rng_name       = "Intel RDRAND Instruction RNG",
+		.rng_fd         = -1,
+#ifdef HAVE_RDRAND
+		.xread          = xread_drng,
+		.init           = init_drng_entropy_source,
+#else
+		.disabled	= true,
+#endif
+	},
+	{
+		.rng_name       = "Power9 DARN Instruction RNG",
+		.rng_fd         = -1,
+#ifdef HAVE_DARN
+		.xread          = xread_darn,
+		.init           = init_darn_entropy_source,
+#else
+		.disabled	= true,
+#endif
+	},
 };
 
-static struct rng rng_drng = {
-	.rng_name	= "drng",
-	.rng_fd  	= -1,
-	.xread  	= xread_drng,
-};
-
-static struct rng rng_tpm = {
-	.rng_name	= "/dev/tpm0",
-	.rng_fd		= -1,
-	.xread		= xread_tpm,
-};
-
-struct rng *rng_list;
 
 /*
  * command line processing
  */
 static error_t parse_opt (int key, char *arg, struct argp_state *state)
 {
+	long int idx;
 	switch(key) {
+	case 'd':
+		arguments->debug = true;
+		break;
 	case 'o':
 		arguments->random_name = arg;
 		break;
+	case 'x':
+		idx = strtol(arg, NULL, 10);
+		if ((idx == LONG_MAX) || (idx > ENT_MAX)) {
+			printf("exclude index is out of range: %d\n", idx);
+			return -ERANGE;
+		}
+		entropy_sources[idx].disabled = true;
+		printf("Disabling %d: %s\n", idx, entropy_sources[idx].rng_name);
+		break;
+	case 'l':
+		arguments->list = true;
+		break;
 	case 'p':
 		arguments->pid_file = arg;
 		break;
 	case 'r':
-		rng_default.rng_name = arg;
+		entropy_sources[ENT_HWRNG].rng_fname = arg;
 		break;
 	case 'f':
 		arguments->daemon = false;
@@ -188,24 +231,8 @@ static error_t parse_opt (int key, char
 		arguments->quiet = true;
 		break;
 	case 'v':
-		arguments->verbose = true;
-		break;
-	case 'd': {
-		int n;
-		if ((sscanf(arg,"%i", &n) == 0) || ((n | 1)!=1))
-			argp_usage(state);
-		else
-			arguments->enable_drng = false;
-		break;
-	}
-	case 'n': {
-		int n;
-		if ((sscanf(arg,"%i", &n) == 0) || ((n | 1)!=1))
-			argp_usage(state);
-		else
-			arguments->enable_tpm = false;
-		break;
-	}
+		printf("%s\n", argp_program_version);
+		return -EAGAIN;
 	case 'e': {
 		int e;
 		if ((sscanf(arg,"%i", &e) == 0) || (e < 0) || (e > 8))
@@ -247,15 +274,17 @@ static void do_loop(int random_step)
 	unsigned char buf[FIPS_RNG_BUFFER_SIZE];
 	int retval = 0;
 	int no_work = 0;
+	int i;
 
 	while (no_work < 100) {
 		struct rng *iter;
 		bool work_done;
 
 		work_done = false;
-		for (iter = rng_list; iter; iter = iter->next)
+		for (i=0; i < ENT_MAX; i++)
 		{
 			int rc;
+			iter = &entropy_sources[i];
 
 			if (!server_running)
 				return;
@@ -311,12 +340,29 @@ static void term_signal(int signo)
 	server_running = false;
 }
 
+static int discard_initial_data(struct rng *ent_src)
+{
+	/* Trash 32 bits of what is probably stale (non-random)
+	 * initial state from the RNG.  For Intel's, 8 bits would
+	 * be enough, but since AMD's generates 32 bits at a time...
+	 *
+	 * The kernel drivers should be doing this at device powerup,
+	 * but at least up to 2.4.24, it doesn't. */
+	unsigned char tempbuf[4];
+	ent_src->xread(tempbuf, sizeof(tempbuf), ent_src);
+
+	/* Return 32 bits of bootstrap data */
+	ent_src->xread(tempbuf, sizeof(tempbuf), ent_src);
+
+	return tempbuf[0] | (tempbuf[1] << 8) |
+		(tempbuf[2] << 16) | (tempbuf[3] << 24);
+}
+
 int main(int argc, char **argv)
 {
-	int rc_rng = 1;
-	int rc_drng = 1;
-	int rc_tpm = 1;
-	int pid_fd = -1;
+	int i;
+	int ent_sources = 0;
+	pid_t pid_fd;
 
 	openlog("rngd", 0, LOG_DAEMON);
 
@@ -324,45 +370,42 @@ int main(int argc, char **argv)
 	arguments->fill_watermark = default_watermark();
 
 	/* Parsing of commandline parameters */
-	argp_parse(&argp, argc, argv, 0, 0, arguments);
-
-	/* Init entropy sources, and open TRNG device */
-	if (arguments->enable_drng)
-		rc_drng = init_drng_entropy_source(&rng_drng);
-	rc_rng = init_entropy_source(&rng_default);
-	if (arguments->enable_tpm && rc_rng)
-		rc_tpm = init_tpm_entropy_source(&rng_tpm);
+	if (argp_parse(&argp, argc, argv, 0, 0, arguments) < 0)
+		return 1;
 
-	if (rc_rng && rc_drng && rc_tpm) {
-		if (!arguments->quiet) {
-			message(LOG_DAEMON|LOG_ERR,
-				"can't open any entropy source");
-			message(LOG_DAEMON|LOG_ERR,
-				"Maybe RNG device modules are not loaded\n");
+	/* Init entropy sources */
+	for (i=0; i < ENT_MAX; i++) {
+		if (entropy_sources[i].disabled == false) {
+			if (!entropy_sources[i].init(&entropy_sources[i])) {
+				ent_sources++;
+				entropy_sources[i].fipsctx = malloc(sizeof(fips_ctx_t));
+				fips_init(entropy_sources[i].fipsctx, discard_initial_data(&entropy_sources[i]));
+			} else {
+				message(LOG_ERR | LOG_DAEMON, "Failed to init entropy source %d: %s\n",
+					i, entropy_sources[i].rng_name);
+				entropy_sources[i].disabled = true;
+			}
 		}
-		return 1;
 	}
 
-	if (arguments->verbose) {
+	if (arguments->list) {
 		printf("Available entropy sources:\n");
-		if (!rc_rng)
-			printf("\tIntel/AMD hardware rng\n");
-		if (!rc_drng)
-			printf("\tDRNG\n");
-		if (!rc_tpm)
-			printf("\tTPM\n");
+		for (i=0; i < ENT_MAX; i++) 
+			if (entropy_sources[i].init && entropy_sources[i].disabled == false)
+				printf("%d: %s\n", i, entropy_sources[i].rng_name);
+			
 		return 1;
 	}
 
-	if (rc_rng
-		&& (rc_drng || !arguments->enable_drng)
-		&& (rc_tpm || !arguments->enable_tpm)) {
-		if (!arguments->quiet)
+	if (!ent_sources) {
+		if (!arguments->quiet) {
 			message(LOG_DAEMON|LOG_ERR,
-		"No entropy source available, shutting down\n");
+				"can't open any entropy source");
+			message(LOG_DAEMON|LOG_ERR,
+				"Maybe RNG device modules are not loaded\n");
+		}
 		return 1;
 	}
-
 	/* Init entropy sink and open random device */
 	init_kernel_rng(arguments->random_name);
 
diff -up ./rngd_darn.c.update ./rngd_darn.c
--- ./rngd_darn.c.update	2017-11-09 07:35:56.702978438 -0500
+++ ./rngd_darn.c	2017-11-09 07:35:56.702978438 -0500
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) 2017, Neil Horman 
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#define _GNU_SOURCE
+
+#ifndef HAVE_CONFIG_H
+#error Invalid or missing autoconf build environment
+#endif
+
+#include "rng-tools-config.h"
+
+#ifndef HAVE_LIBGCRYPT
+#error power DARN support requires libgcrypt!
+#endif
+
+#include <unistd.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <syslog.h>
+#include <string.h>
+#include <stddef.h>
+#include <limits.h>
+#include <sysfs/libsysfs.h>
+#include <gcrypt.h>
+
+
+#include "rngd.h"
+#include "fips.h"
+#include "exits.h"
+#include "rngd_entsource.h"
+
+#define min(x,y) ({ \
+	typeof(x) _x = (x);     \
+	typeof(y) _y = (y);     \
+	(void) (&_x == &_y);    \
+	_x < _y ? _x : _y; })
+
+static uint64_t get_darn();
+static int refill_rand();
+static size_t copy_avail_rand_to_buf(unsigned char *buf, size_t size, size_t copied);
+
+#define SYSFS_CPU_MODALIAS "/sys/devices/system/cpu/modalias"
+#define AES_BLOCK 16
+#define CHUNK_SIZE AES_BLOCK * 8
+#define THRESH_BITS 14
+
+static gcry_cipher_hd_t gcry_cipher_hd;
+static unsigned char iv_buf[AES_BLOCK];
+
+static unsigned char darn_rand_buf[CHUNK_SIZE];
+static size_t darn_buf_avail = 0;
+static size_t darn_buf_ptr = CHUNK_SIZE - 1;
+
+static size_t rekey_thresh = (1 << THRESH_BITS);
+static size_t rand_bytes_served = 0;
+
+static int init_gcrypt()
+{
+	unsigned char key[AES_BLOCK];
+	unsigned char xkey[AES_BLOCK];
+	int i;
+	uint64_t darn_val;
+	gcry_error_t gcry_error;
+
+	/*
+	 * Use stack junk to create a key, shuffle it a bit
+	 */
+	for (i=0; i< sizeof(key); i++)
+		key[i] ^= xkey[i];
+
+	darn_val = get_darn();
+	if (darn_val == ULONG_MAX)
+		return 1;
+	memcpy(&iv_buf[0], &darn_val, sizeof(uint64_t));
+	
+	darn_val = get_darn();
+	if (darn_val == ULONG_MAX)
+		return 1;
+	memcpy(&iv_buf[8], &darn_val, sizeof(uint64_t));
+
+	gcry_error = gcry_cipher_open(&gcry_cipher_hd, GCRY_CIPHER_AES128,
+				      GCRY_CIPHER_MODE_CBC, 0);
+
+	if (!gcry_error)
+		gcry_error = gcry_cipher_setkey(gcry_cipher_hd, key, AES_BLOCK);
+
+	if (!gcry_error) {
+		/*
+		 * Only need the first 16 bytes of iv_buf. AES-NI can
+		 * encrypt multiple blocks in parallel but we can't.
+		 */
+		gcry_error = gcry_cipher_setiv(gcry_cipher_hd, iv_buf, AES_BLOCK);
+	}
+
+	if (gcry_error) {
+		message(LOG_DAEMON|LOG_ERR,
+			"could not set key or IV: %s\n",
+			gcry_strerror(gcry_error));
+		gcry_cipher_close(gcry_cipher_hd);
+		return 1;
+	}
+
+	rand_bytes_served = 0;
+	if (refill_rand())
+		return 1;
+	if (copy_avail_rand_to_buf((unsigned char *)&rekey_thresh, sizeof(size_t), 0) < sizeof(size_t))
+		return 1;
+	rekey_thresh &= ((1 << THRESH_BITS)-1);
+	
+	return 0;
+}
+
+static int refill_rand()
+{
+	gcry_error_t gcry_error;
+
+	if (darn_buf_avail)
+		return 0;
+
+	if (rand_bytes_served >= rekey_thresh) {
+		message(LOG_DAEMON|LOG_DEBUG, "rekeying DARN rng\n");
+		gcry_cipher_close(gcry_cipher_hd);
+		if (init_gcrypt())
+			return 1;
+	}
+
+	gcry_error = gcry_cipher_encrypt(gcry_cipher_hd, darn_rand_buf,
+					CHUNK_SIZE, NULL, 0);
+
+	if (gcry_error) {
+		message(LOG_DAEMON | LOG_ERR,
+			"gcry_cipher_encrypt_error: %s\n",
+			gcry_strerror(gcry_error));
+		return 1;
+	}
+
+	darn_buf_avail = CHUNK_SIZE;
+	darn_buf_ptr = 0;
+	return 0;
+}
+
+static size_t copy_avail_rand_to_buf(unsigned char *buf, size_t size, size_t copied)
+{
+	size_t left_to_copy = size - copied;
+	size_t to_copy = min(left_to_copy, darn_buf_avail);
+
+	memcpy(&buf[copied], &darn_rand_buf[darn_buf_ptr], to_copy);
+
+	darn_buf_avail -= to_copy;
+	darn_buf_ptr += to_copy;
+	rand_bytes_served += to_copy;
+	return to_copy;
+}
+
+/*
+ * Runs the get_darn instruction, returns ULONG_MAX on error
+ */
+static uint64_t get_darn()
+{
+	uint64_t darn_val;
+	darn_val = 0;
+	int i;
+
+	/*
+	 * For loop is taken from PowerISA_public.v3.0B 
+	 * programming guide
+	 */
+	for (i=0; i < 10; i++){
+		asm("darn %0, 1" : "=r" (darn_val) );
+		if (darn_val != ULONG_MAX)
+			break;
+	}
+
+	return darn_val;
+}
+
+
+int xread_darn(void *buf, size_t size, struct rng *ent_src)
+{
+	uint64_t *darn_ptr =(uint64_t *)buf;
+	uint64_t darn_val;
+	size_t copied = 0;
+
+	while (copied < size) {
+		if (refill_rand()) {
+			return 1;
+		}
+		copied += copy_avail_rand_to_buf(buf, size, copied);
+	}
+	return 0;
+}
+
+/*
+ * Confirm DARN capabilities for drng entropy source
+ */
+int init_darn_entropy_source(struct rng *ent_src)
+{
+	struct sysfs_attribute *cpu;
+	char *ptr;
+	unsigned long flags;
+
+	cpu = sysfs_open_attribute(SYSFS_CPU_MODALIAS);
+	if (!cpu)
+		return 1;
+	if (sysfs_read_attribute(cpu)) {
+		sysfs_close_attribute(cpu);
+		return 1;
+	}
+
+	/*
+	 * Check the modalias string for power9, as only that power ISA 
+	 * currently supports DARN
+	 */
+	if (!strstr(cpu->value, "power9")) {
+		sysfs_close_attribute(cpu);
+		return 1;
+	}
+
+	/*
+	 * Pull out bit 22 from the cpu feature flags, as
+	 * that marks if the cpu supports DARN
+	 */
+	ptr = strrchr(cpu->value, ',');
+	*ptr = 0;
+	ptr = strrchr(cpu->value, ',');
+	ptr += 3; /*skip leading zeros and comma*/
+	flags = strtoul(ptr, NULL, 16);	
+	if (!(flags & 0x20)) {
+		sysfs_close_attribute(cpu);
+		return 1;
+	}
+	sysfs_close_attribute(cpu);
+
+	if (init_gcrypt())
+		return 1;
+	message(LOG_DAEMON|LOG_INFO, "Enabling power DARN rng support\n");
+	return 0;
+}
diff -up ./rngd_entsource.c.update ./rngd_entsource.c
--- ./rngd_entsource.c.update	2017-11-09 07:34:35.757304376 -0500
+++ ./rngd_entsource.c	2017-11-09 07:36:53.208750909 -0500
@@ -64,8 +64,10 @@ int xread(void *buf, size_t size, struct
 		size -= r;
 	}
 
-	if (size)
+	if (size) {
+		message(LOG_DAEMON|LOG_DEBUG, "read error\n");
 		return -1;
+	}
 	return 0;
 }
 
@@ -86,9 +88,9 @@ int xread_tpm(void *buf, size_t size, st
 	};
 	char *offset;
 
-	ent_src->rng_fd = open(ent_src->rng_name, O_RDWR);
+	ent_src->rng_fd = open(ent_src->rng_fname, O_RDWR);
 	if (ent_src->rng_fd == -1) {
-		message(LOG_ERR|LOG_INFO,"Unable to open file: %s",ent_src->rng_name);
+		message(LOG_DAEMON|LOG_DEBUG,"Unable to open file: %s",ent_src->rng_fname);
 		return -1;
 	}
 
@@ -150,27 +152,6 @@ error_out:
 	return retval;
 }
 
-/* Initialize entropy source */
-static int discard_initial_data(struct rng *ent_src, int *buf)
-{
-	/* Trash 32 bits of what is probably stale (non-random)
-	 * initial state from the RNG.  For Intel's, 8 bits would
-	 * be enough, but since AMD's generates 32 bits at a time...
-	 *
-	 * The kernel drivers should be doing this at device powerup,
-	 * but at least up to 2.4.24, it doesn't. */
-	unsigned char tempbuf[4];
-	xread(tempbuf, sizeof(tempbuf), ent_src);
-
-	/* Return 32 bits of bootstrap data */
-	if (xread(tempbuf, sizeof(tempbuf), ent_src) != 0)
-		return -1;
-
-	*buf = tempbuf[0] | (tempbuf[1] << 8) |
-		(tempbuf[2] << 16) | (tempbuf[3] << 24);
-	return 0;
-}
-
 #define RNG_AVAIL "/sys/devices/virtual/misc/hw_random/rng_available"
 
 /*
@@ -182,9 +163,9 @@ int init_entropy_source(struct rng *ent_
 	char buf[16];
 	int bootstrap;
 
-	ent_src->rng_fd = open(ent_src->rng_name, O_RDONLY);
+	ent_src->rng_fd = open(ent_src->rng_fname, O_RDONLY);
 	if (ent_src->rng_fd == -1) {
-		message(LOG_ERR|LOG_INFO, "Unable to open file: %s", ent_src->rng_name);
+		message(LOG_DAEMON|LOG_DEBUG, "Unable to open file: %s", ent_src->rng_fname);
 		return 1;
 	}
 
@@ -199,32 +180,26 @@ int init_entropy_source(struct rng *ent_
 	 */
 	rngavail = sysfs_open_attribute(RNG_AVAIL);
 	if (!rngavail) {
-		message(LOG_ERR|LOG_INFO, "Unable to open sysfs attribute: %s", RNG_AVAIL);
+		message(LOG_DAEMON|LOG_DEBUG, "Unable to open sysfs attribute: %s", RNG_AVAIL);
 		return 1;
 	}
 
 	if (sysfs_read_attribute(rngavail)) {
-		message(LOG_ERR|LOG_INFO, "Error reading sysfs attribute: %s", RNG_AVAIL);
+		message(LOG_DAEMON|LOG_DEBUG, "Error reading sysfs attribute: %s", RNG_AVAIL);
 		sysfs_close_attribute(rngavail);
 		return 1;
 	}
 
 	if (strncmp(rngavail->value, "\n", 1) == 0) {
-		message(LOG_ERR|LOG_INFO, "hwrng: no available rng");
+		message(LOG_DAEMON|LOG_DEBUG, "hwrng: no available rng");
 		sysfs_close_attribute(rngavail);
 		return 1;
 	}
 	sysfs_close_attribute(rngavail);
 
 source_valid:
-	src_list_add(ent_src);
 	/* Bootstrap FIPS tests */
 	ent_src->fipsctx = malloc(sizeof(fips_ctx_t));
-	if (discard_initial_data(ent_src, &bootstrap) != 0) {
-		message(LOG_ERR|LOG_INFO, "Read failure in hwrng during bootstrap\n");
-		return 1;
-	}
-	fips_init(ent_src->fipsctx, bootstrap);
 	return 0;
 }
 
@@ -233,15 +208,13 @@ source_valid:
  */
 int init_tpm_entropy_source(struct rng *ent_src)
 {
-	ent_src->rng_fd = open(ent_src->rng_name, O_RDWR);
+	ent_src->rng_fd = open(ent_src->rng_fname, O_RDWR);
 	if (ent_src->rng_fd == -1) {
-		message(LOG_ERR|LOG_INFO,"Unable to open file: %s",ent_src->rng_name);
+		message(LOG_DAEMON|LOG_DEBUG,"Unable to open file: %s",ent_src->rng_fname);
 		return 1;
 	}
-	src_list_add(ent_src);
 	/* Bootstrap FIPS tests */
 	ent_src->fipsctx = malloc(sizeof(fips_ctx_t));
-	fips_init(ent_src->fipsctx, 0);
 	close(ent_src->rng_fd);
 	return 0;
 }
diff -up ./rngd_entsource.h.update ./rngd_entsource.h
--- ./rngd_entsource.h.update	2014-04-01 01:03:31.000000000 -0400
+++ ./rngd_entsource.h	2017-11-09 07:35:56.702978438 -0500
@@ -41,7 +41,14 @@ extern int init_tpm_entropy_source(struc
 
 /* Read data from the entropy source */
 extern int xread(void *buf, size_t size, struct rng *ent_src);
+#ifdef HAVE_RDRAND
 extern int xread_drng(void *buf, size_t size, struct rng *ent_src);
+#endif
+
+#ifdef HAVE_DARN
+extern int xread_darn(void *buf, size_t size, struct rng *ent_src);
+#endif
+
 extern int xread_tpm(void *buf, size_t size, struct rng *ent_src);
 
 #endif /* RNGD_ENTSOURCE__H */
diff -up ./rngd.h.update ./rngd.h
--- ./rngd.h.update	2017-11-09 07:34:35.749304409 -0500
+++ ./rngd.h	2017-11-09 07:35:56.701978442 -0500
@@ -46,9 +46,10 @@ struct arguments {
 	int random_step;
 	int fill_watermark;
 
+	bool debug;
 	bool quiet;
-	bool verbose;
 	bool daemon;
+	bool list;
 	bool ignorefail;
 	bool enable_drng;
 	bool enable_tpm;
@@ -59,12 +60,14 @@ extern struct arguments *arguments;
 /* structures to store rng information */
 struct rng {
 	char *rng_name;
+	char *rng_fname;
 	int rng_fd;
 	bool disabled;
 	int failures;
 	int success;
 
 	int (*xread) (void *buf, size_t size, struct rng *ent_src);
+	int (*init) (struct rng *ent_src);
 	fips_ctx_t *fipsctx;
 
 	struct rng *next;
@@ -81,12 +84,13 @@ extern bool am_daemon;			/* True if we w
 	if (am_daemon) { \
 		syslog((priority), fmt, ##args); \
 	} else { \
-		fprintf(stderr, fmt, ##args); \
-		fprintf(stderr, "\n"); \
+		if ((LOG_PRI(priority) != LOG_DEBUG) || (arguments->debug == true)) {\
+			fprintf(stderr, fmt, ##args); \
+			fprintf(stderr, "\n"); \
+		} \
 	} \
 } while (0)
 
-extern void src_list_add(struct rng *ent_src);
 extern int write_pid_file(const char *pid_fn);
 #endif /* RNGD__H */
 
diff -up ./rngd_linux.c.update ./rngd_linux.c
--- ./rngd_linux.c.update	2017-11-09 07:34:35.749304409 -0500
+++ ./rngd_linux.c	2017-11-09 07:35:56.702978438 -0500
@@ -48,8 +48,6 @@
 #include "exits.h"
 #include "rngd_linux.h"
 
-extern struct rng *rng_list;
-
 /* Kernel output device */
 static int random_fd;
 
@@ -146,18 +144,3 @@ void random_sleep(void)
 
 	poll(&pfd, 1, -1);
 }
-
-void src_list_add(struct rng *ent_src)
-{
-	if (rng_list) {
-		struct rng *iter;
-
-		iter = rng_list;
-		while (iter->next) {
-			iter = iter->next;
-		}
-		iter->next = ent_src;
-	} else {
-		rng_list = ent_src;
-	}
-}
diff -up ./rngd_rdrand.c.update ./rngd_rdrand.c
--- ./rngd_rdrand.c.update	2014-04-01 01:03:31.000000000 -0400
+++ ./rngd_rdrand.c	2017-11-09 07:35:56.702978438 -0500
@@ -46,7 +46,6 @@
 #include "exits.h"
 #include "rngd_entsource.h"
 
-#if defined(__i386__) || defined(__x86_64__)
 
 /* Struct for CPUID return values */
 struct cpuid {
@@ -351,28 +350,5 @@ int init_drng_entropy_source(struct rng
 	if (init_aesni(key) && init_gcrypt(key))
 		return 1;	/* We need one crypto or the other... */
 
-	src_list_add(ent_src);
-	/* Bootstrap FIPS tests */
-	ent_src->fipsctx = malloc(sizeof(fips_ctx_t));
-	fips_init(ent_src->fipsctx, 0);
 	return 0;
 }
-
-#else /* Not i386 or x86-64 */
-
-int init_drng_entropy_source(struct rng *ent_src)
-{
-	(void)ent_src;
-	return 1;
-}
-
-int xread_drng(void *buf, size_t size, struct rng *ent_src)
-{
-	(void)buf;
-	(void)size;
-	(void)ent_src;
-
-	return -1;
-}
-
-#endif /* Not i386 or x86-64 */
